CREATE TABLE public.profiles (
  id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  username text UNIQUE,
  bio text,
  interests text[], -- Array of strings for interests
  avatar_url text,
  beacon_id text UNIQUE, -- Unique ID for Bluetooth/QR scanning
  -- Optional presence/geolocation fields used by the helper function find_nearby_users.
  -- BLE encounter history is stored per event in encounters.locations and is the source of truth
  -- for "where we met". These profile-level fields are only for coarse, last-known location
  -- and online presence and can be removed if you don't use geolocation discovery.
  latitude float, -- Last known latitude (optional, for proximity discovery/presence only)
  longitude float, -- Last known longitude (optional, for proximity discovery/presence only)
  last_seen_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL -- Last presence update
);

-- Enable Row Level Security (RLS)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Create a table for encounters (waves/matches)
CREATE TABLE public.encounters (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_a uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  user_b uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  meet_count int DEFAULT 1,
  last_met_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  waved_a boolean DEFAULT false, -- Did user_a wave?
  waved_b boolean DEFAULT false, -- Did user_b wave?
  is_matched boolean DEFAULT false, -- True if both waved
  locations jsonb DEFAULT '[]'::jsonb, -- Array of {lat, long, timestamp}
  UNIQUE(user_a, user_b)
);

-- Enable RLS
ALTER TABLE public.encounters ENABLE ROW LEVEL SECURITY;

-- Create a table for messages
CREATE TABLE public.messages (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  encounter_id bigint REFERENCES public.encounters(id) ON DELETE CASCADE NOT NULL,
  sender_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  content text NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Enable RLS
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- POLICIES (For Hackathon: Open Access)
-- In production, you would restrict these!
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Encounters are viewable by everyone." ON public.encounters FOR SELECT USING (true);
CREATE POLICY "Encounters are insertable by everyone." ON public.encounters FOR INSERT WITH CHECK (true);
CREATE POLICY "Encounters are updatable by everyone." ON public.encounters FOR UPDATE USING (true);

CREATE POLICY "Messages are viewable by everyone." ON public.messages FOR SELECT USING (true);
CREATE POLICY "Messages are insertable by everyone." ON public.messages FOR INSERT WITH CHECK (true);

-- VIEW: My Orbit Feed
-- Simplifies fetching people you've met
CREATE OR REPLACE VIEW my_orbit_feed AS
SELECT
    e.id AS encounter_id,
    CASE WHEN e.user_a = auth.uid() THEN e.user_b ELSE e.user_a END AS other_user_id,
    p.username AS other_username,
    p.avatar_url AS other_avatar,
    p.bio AS other_bio,
    p.beacon_id AS other_beacon_id,
    e.meet_count,
    e.last_met_at,
    e.is_matched,
    e.locations, -- Include locations in the view
    CASE WHEN e.user_a = auth.uid() THEN e.waved_a ELSE e.waved_b END AS have_i_waved,
    CASE WHEN e.user_a = auth.uid() THEN e.waved_b ELSE e.waved_a END AS has_waved_at_me
FROM public.encounters e
JOIN public.profiles p ON p.id = (CASE WHEN e.user_a = auth.uid() THEN e.user_b ELSE e.user_a END)
WHERE e.user_a = auth.uid() OR e.user_b = auth.uid();

-- FUNCTION: Scan Beacon
-- Called when User A scans User B's beacon ID
CREATE OR REPLACE FUNCTION scan_beacon(target_beacon_id text, lat float DEFAULT NULL, long float DEFAULT NULL)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  target_user_id uuid;
  existing_encounter_id bigint;
  new_count int;
  new_location jsonb;
BEGIN
  -- 1. Find the user with this beacon_id
  SELECT id INTO target_user_id FROM public.profiles WHERE beacon_id = target_beacon_id;

  IF target_user_id IS NULL THEN
    RETURN json_build_object('status', 'unknown_beacon');
  END IF;

  IF target_user_id = auth.uid() THEN
    RETURN json_build_object('status', 'ignored_self');
  END IF;

  -- Prepare location object
  IF lat IS NOT NULL AND long IS NOT NULL THEN
    new_location := json_build_object('lat', lat, 'long', long, 'timestamp', now());
  ELSE
    new_location := NULL;
  END IF;

  -- 2. Check if encounter exists
  SELECT id, meet_count INTO existing_encounter_id, new_count 
  FROM public.encounters 
  WHERE (user_a = auth.uid() AND user_b = target_user_id) 
     OR (user_a = target_user_id AND user_b = auth.uid());

  IF existing_encounter_id IS NOT NULL THEN
    -- Update existing
    UPDATE public.encounters 
    SET meet_count = meet_count + 1,
        last_met_at = now(),
        locations = CASE
            WHEN new_location IS NOT NULL THEN (
                CASE
                    WHEN jsonb_typeof(locations) = 'array' THEN locations || jsonb_build_array(new_location)
                    ELSE jsonb_build_array(new_location)
                END
            )
            ELSE locations
        END
    WHERE id = existing_encounter_id;
    RETURN json_build_object('status', 'success', 'count', new_count + 1);
  ELSE
    -- Create new
    INSERT INTO public.encounters (user_a, user_b, meet_count, locations)
    VALUES (auth.uid(), target_user_id, 1, CASE WHEN new_location IS NOT NULL THEN jsonb_build_array(new_location) ELSE '[]'::jsonb END);
    RETURN json_build_object('status', 'success', 'count', 1);
  END IF;
END;
$$;

-- FUNCTION: Wave at Person
-- Called when User A waves at User B (via encounter_id)
CREATE OR REPLACE FUNCTION wave_at_person(encounter_id_input bigint)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  enc_record public.encounters%ROWTYPE;
BEGIN
  SELECT * INTO enc_record FROM public.encounters WHERE id = encounter_id_input;

  IF enc_record IS NULL THEN
    RETURN json_build_object('status','error_not_found');
  END IF;

  -- CHECK: Must have met at least 3 times
  IF enc_record.meet_count < 3 THEN
    RETURN json_build_object('status','error_too_soon', 'meet_count', enc_record.meet_count);
  END IF;

  -- Update the wave status
  IF enc_record.user_a = auth.uid() THEN
    UPDATE public.encounters SET waved_a = true WHERE id = encounter_id_input;
    -- Check match
    IF enc_record.waved_b = true THEN
        UPDATE public.encounters SET is_matched = true WHERE id = encounter_id_input;
        RETURN json_build_object('status','matched', 'locations', enc_record.locations);
    END IF;
  ELSE
    UPDATE public.encounters SET waved_b = true WHERE id = encounter_id_input;
    -- Check match
    IF enc_record.waved_a = true THEN
        UPDATE public.encounters SET is_matched = true WHERE id = encounter_id_input;
        RETURN json_build_object('status','matched', 'locations', enc_record.locations);
    END IF;
  END IF;

  RETURN json_build_object('status','waved', 'locations', enc_record.locations);
END;
$$;

-- FUNCTION: Find Nearby Users (Geolocation)
-- Finds users within a radius (meters) and creates/updates encounters
CREATE OR REPLACE FUNCTION find_nearby_users(lat float, long float, radius_meters float)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  nearby_user RECORD;
  found_count int := 0;
  existing_encounter_id bigint;
  new_location jsonb;
BEGIN
  -- Update my location first
  UPDATE public.profiles 
  SET latitude = lat, longitude = long, last_seen_at = now()
  WHERE id = auth.uid();

  -- Loop through users within radius (simple Euclidean approximation for hackathon, or use PostGIS if available)
  -- 1 degree lat ~= 111km. 1 degree lon ~= 111km * cos(lat). 
  -- For simplicity/hackathon: 0.005 degrees is roughly 500m.
  -- Let's use a rough box search for speed/simplicity without PostGIS extension
  
  FOR nearby_user IN 
    SELECT * FROM public.profiles 
    WHERE id != auth.uid()
    AND latitude BETWEEN lat - 0.005 AND lat + 0.005 -- Rough box ~500m
    AND longitude BETWEEN long - 0.005 AND long + 0.005
  LOOP
    -- Prepare a location object for this encounter attempt
    new_location := json_build_object('lat', lat, 'long', long, 'timestamp', now());
    -- Create or Update Encounter
    -- (Logic similar to scan_beacon but automatic)
    
    SELECT id INTO existing_encounter_id
    FROM public.encounters 
    WHERE (user_a = auth.uid() AND user_b = nearby_user.id) 
       OR (user_a = nearby_user.id AND user_b = auth.uid());

    IF existing_encounter_id IS NOT NULL THEN
       -- Only update if not met recently (e.g. > 5 mins ago) to avoid spamming count
       UPDATE public.encounters 
       SET meet_count = meet_count + 1,
           last_met_at = now(),
           locations = CASE
               WHEN jsonb_typeof(locations) = 'array' THEN locations || jsonb_build_array(new_location)
               ELSE jsonb_build_array(new_location)
           END
       WHERE id = existing_encounter_id 
       AND last_met_at < now() - interval '5 minutes';
    ELSE
       INSERT INTO public.encounters (user_a, user_b, meet_count, locations)
       VALUES (auth.uid(), nearby_user.id, 1, jsonb_build_array(new_location));
    END IF;
    
    found_count := found_count + 1;
  END LOOP;

  RETURN json_build_object('status', 'success', 'found', found_count);
END;
$$;
